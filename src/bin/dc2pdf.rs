//! Decodes a PDF generated by `c2pdf` and generates the corresponding folders and files
use core::panic;
use std::{
  fs,
  iter::{Map, Peekable},
  mem,
  path::{Path, PathBuf},
  slice::Iter,
};

use printpdf::{self, Op, PdfPage, TextItem};
use two_face::theme::EmbeddedLazyThemeSet;
fn parse_sections(page: &PdfPage) -> Vec<Vec<String>> {
  let mut sections: Vec<Vec<String>> = vec![];
  // Set of lines for the current section
  let mut current_section: Vec<String> = vec![];
  let mut current_line: String = String::new();
  // Sort text into sets of lines for each position
  for op in &page.ops {
    match op {
      // `SetTextMatrix` or `SetTextCursor` should create a new section
      Op::SetTextMatrix { matrix: _ } | Op::SetTextCursor { pos: _ } => {
        if !current_section.is_empty() {
          let section = mem::take(&mut current_section);
          sections.push(section);
        }
      }
      // Op::SetTextCursor { pos } => {}
      Op::WriteText { items, font: _font } => {
        for item in items {
          match item {
            TextItem::Text(text) => {
              current_line.push_str(text.trim_matches(&['\r', '\n']));
            }
            _ => {}
          }
        }
      }
      Op::AddLineBreak => {
        // if !current_line.is_empty() {
        let mut line = mem::take(&mut current_line);
        line.push('\n');
        current_section.push(line);
        // }
      }
      _ => {}
    }
  }
  if !current_line.is_empty() {
    current_section.push(current_line);
  }
  if !current_section.is_empty() {
    sections.push(current_section);
  }
  sections
}
#[derive(Debug)]
struct PageData {
  path: PathBuf,
  custom_text: Option<String>,
  contents: String,
}
impl PageData {
  fn parse_path(path_section: &Vec<String>) -> PathBuf {
    let path_str = path_section.join("");
    PathBuf::from(path_str.trim())
  }
  fn parse_contents(contents_section: &Vec<String>) -> String {
    contents_section.join("")
  }
  pub fn parse_from_sections(sections: Vec<Vec<String>>) -> Self {
    match sections.len() {
      // No custom text
      2 => {
        let path = Self::parse_path(&sections[0]);
        let contents = Self::parse_contents(&sections[1]);

        Self {
          path,
          custom_text: None,
          contents,
        }
      }
      // Custom text
      3 => {
        let path = Self::parse_path(&sections[0]);
        let contents = Self::parse_contents(&sections[2]);
        Self {
          path,
          custom_text: None,
          contents,
        }
      }
      _ => {
        panic!("Malformed PDF")
      }
    }
  }
}
#[derive(Debug)]
struct FileData {
  path: PathBuf,
  contents: String,
}
fn next_file_data<I: Iterator<Item = PageData>>(pages: &mut Peekable<I>) -> Option<FileData> {
  let page = if let Some(p) = pages.next() {
    p
  } else {
    return None;
  };
  let PageData {
    path,
    mut contents,
    custom_text: _custom_text,
  } = page;
  while let Some(peeked) = pages.peek() {
    if peeked.path == path {
      let data = pages.next().unwrap();
      let c = data.contents;
      contents.push_str(&c);
    } else {
      break;
    }
  }

  Some(FileData { path, contents })
}

fn main() {
  let pdf_bytes = include_bytes!("../../output.pdf");
  let doc = printpdf::PdfDocument::parse(pdf_bytes, &Default::default(), &mut vec![]).unwrap();
  let mut pages_iterator = doc
    .pages
    .iter()
    .map(|p| PageData::parse_from_sections(parse_sections(p)))
    .peekable();
  while let Some(file_data) = next_file_data(&mut pages_iterator) {
    let base = PathBuf::from("./generated");
    let file_path = base.join(file_data.path);
    fs::create_dir_all(&file_path.parent().unwrap()).unwrap();
    fs::write(file_path, file_data.contents).unwrap();
  }
}
